package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"strings"

	"github.com/faunists/deal/protogen/deal/v1/contract"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/dynamicpb"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/faunists/deal/entities"
	"github.com/faunists/deal/processors"
)

const (
	contextPackage = protogen.GoImportPath("context")
	grpcPackage    = protogen.GoImportPath("google.golang.org/grpc")
	grpcCodes      = protogen.GoImportPath("google.golang.org/grpc/codes")
	grpcStatus     = protogen.GoImportPath("google.golang.org/grpc/status")
	protoPackage   = protogen.GoImportPath("google.golang.org/protobuf/proto")
)

func main() {
	// TODO: Add flags to be used to give the user the option between flags or service option
	var flags flag.FlagSet

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, file := range plugin.Files {
			if file.Generate {
				_, err := generateContracts(plugin, file)
				if err != nil {
					return err
				}
			}
		}

		return nil
	})
}

func generateContracts( //nolint:gocognit // this function only call the functions to generate cases
	plugin *protogen.Plugin,
	file *protogen.File,
) (*protogen.GeneratedFile, error) {
	if len(file.Services) == 0 {
		return nil, nil
	}

	filename := fmt.Sprintf("%s_contract.pb.go", file.GeneratedFilenamePrefix)
	newFile := plugin.NewGeneratedFile(filename, file.GoImportPath)

	writeHeader(file, newFile)

	for _, service := range file.Services {
		// Get service options
		serviceOptions, ok := service.Desc.Options().(*descriptorpb.ServiceOptions)
		if !ok {
			return nil, fmt.Errorf("failed to parse the service options")
		}

		// Try to get our extension information
		contractExtension := proto.GetExtension(serviceOptions, contract.E_DealContract)
		contractOption, ok := contractExtension.(*contract.DealContract)
		if !ok {
			return nil, fmt.Errorf("failed to parse the contract")
		}

		// Parse contract JSON file that was defined in the service options
		rawContract, err := processors.ReadContractFile(contractOption.ContractFile)
		if err != nil {
			return nil, err
		}

		// Verifies if the file has a contract for the given service
		serviceContract, hasContract := rawContract.Services[service.GoName]
		if !hasContract {
			continue
		}

		err = generateClient(newFile, service, serviceContract)
		if err != nil {
			return nil, err
		}
	}

	return newFile, nil
}

func writeHeader(originalFile *protogen.File, generatedFile *protogen.GeneratedFile) {
	generatedFile.P("// Code generated by protoc-gen-go-contract")
	generatedFile.P("//")
	generatedFile.P("// versions:")
	generatedFile.P("//   - protoc")
	generatedFile.P()
	generatedFile.P(fmt.Sprintf("package %s", originalFile.GoPackageName))
	generatedFile.P()
}

func generateClient(
	file *protogen.GeneratedFile,
	service *protogen.Service,
	contractService entities.Service,
) error {
	clientName := fmt.Sprintf("%sContractClient", processors.MakeExportedName(service.GoName))

	// Create client struct
	file.P(fmt.Sprintf("type %s struct {}", clientName))

	// Iterate over the service methods and generate the proper method containing a
	// switch case based on the Request/Response provided by the user through JSON File
	for _, method := range service.Methods {
		// We don't need to care about if a contract to the specific method exists or not,
		// 'cause the method will be created with a default switch case in order to satisfy
		// the client interface generated by `protoc-gen-go-grpc`.
		methodContract := contractService[method.GoName]
		switchCase, err := generateClientCases(file, method, methodContract)
		if err != nil {
			return err
		}

		file.P(
			fmt.Sprintf(
				"func (_ %s) %s(ctx %s, in *%s, opts ...%s) (*%s, error) {%s}",
				clientName,
				method.GoName,
				file.QualifiedGoIdent(contextPackage.Ident("Context")),
				file.QualifiedGoIdent(method.Input.GoIdent),
				file.QualifiedGoIdent(grpcPackage.Ident("CallOption")),
				file.QualifiedGoIdent(method.Output.GoIdent),
				switchCase,
			),
		)
		file.P()
	}
	return nil
}

func generateClientCases(
	file *protogen.GeneratedFile,
	method *protogen.Method,
	methodContract entities.Method,
) (string, error) {
	switchCase := bytes.NewBufferString("switch {")

	err := generateSuccessCases(file, method, methodContract.SuccessCases, switchCase)
	if err != nil {
		return "", fmt.Errorf("failed to generate the success cases: %w", err)
	}

	err = generateFailureCases(file, method, methodContract.FailureCases, switchCase)
	if err != nil {
		return "", fmt.Errorf("failed to generate the failure cases: %w", err)
	}

	// Default case if no cases are provided
	switchCase.WriteString("default: return nil, nil }")

	return switchCase.String(), nil
}

func generateSuccessCases(
	file *protogen.GeneratedFile,
	method *protogen.Method,
	cases []entities.SuccessCase,
	writer io.StringWriter,
) error {
	for _, successCase := range cases {
		requestRepresentation, err := getProtoRepresentation(
			successCase.Request, method.Input, file,
		)
		if err != nil {
			return err
		}

		responseRepresentation, err := getProtoRepresentation(
			successCase.Response, method.Output, file,
		)
		if err != nil {
			return err
		}

		_, err = writer.WriteString(
			fmt.Sprintf(
				"case %s(in, %s):\n// Description: %s\n return %s, nil\n",
				file.QualifiedGoIdent(protoPackage.Ident("Equal")),
				requestRepresentation,
				successCase.Description,
				responseRepresentation,
			),
		)
		if err != nil {
			return fmt.Errorf("error writing a success case: %w", err)
		}
	}

	return nil
}

func generateFailureCases(
	file *protogen.GeneratedFile,
	method *protogen.Method,
	cases []entities.FailureCase,
	writer io.StringWriter,
) error {
	for _, failureCase := range cases {
		requestRepresentation, err := getProtoRepresentation(
			failureCase.Request, method.Input, file,
		)
		if err != nil {
			return err
		}

		if !processors.IsErrorCodeValid(failureCase.Error.ErrorCode) {
			return fmt.Errorf("invalid error code: %s", failureCase.Error.ErrorCode)
		}

		_, err = writer.WriteString(
			fmt.Sprintf(
				"case %s(in, %s):\n// Description: %s\n return nil, %s(%s, %q)\n",
				file.QualifiedGoIdent(protoPackage.Ident("Equal")),
				requestRepresentation,
				failureCase.Description,
				file.QualifiedGoIdent(grpcStatus.Ident("Errorf")),
				file.QualifiedGoIdent(grpcCodes.Ident(failureCase.Error.ErrorCode)),
				failureCase.Error.Message,
			),
		)
		if err != nil {
			return fmt.Errorf("error writing a success case: %w", err)
		}
	}

	return nil
}

func getProtoRepresentation(
	r interface{},
	message *protogen.Message,
	file *protogen.GeneratedFile,
) (string, error) {
	marshaledRequest, err := json.Marshal(r)
	if err != nil {
		return "", err
	}

	messageArguments, err := inputOutputToString(marshaledRequest, message)
	if err != nil {
		return "", fmt.Errorf("failed to generate message representation: %w", err)
	}

	return fmt.Sprintf(
		"&%s{%s}",
		file.QualifiedGoIdent(message.GoIdent),
		strings.Join(messageArguments, ","),
	), nil
}

func inputOutputToString(data []byte, message *protogen.Message) ([]string, error) {
	// This step validates the data provided by the user through JSON file
	methodInputMessage := dynamicpb.NewMessage(message.Desc)
	err := protojson.Unmarshal(data, methodInputMessage)
	if err != nil {
		return nil, err
	}

	// Making this map we're able to correlate a field with a field descriptor
	fieldsMapByNumber := make(map[protoreflect.FieldNumber]*protogen.Field)
	for _, field := range message.Fields {
		fieldsMapByNumber[field.Desc.Number()] = field
	}

	// Try to get all of the populated fields (name and value)
	messageArguments := make([]string, 0)
	methodInputMessage.Range(
		func(descriptor protoreflect.FieldDescriptor, value protoreflect.Value) bool {
			field, exists := fieldsMapByNumber[descriptor.Number()]
			if !exists {
				err = fmt.Errorf(
					"field not found %s while inspecting message %s",
					descriptor.Name(), message.Desc.Name(),
				)
				return false
			}

			messageArguments = append(
				messageArguments,
				fmt.Sprintf("%s: %s", field.GoName, processors.FormatFieldValue(value)),
			)

			return true
		},
	)
	if err != nil {
		return nil, err
	}

	return messageArguments, nil
}
